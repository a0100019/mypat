package com.a0100019.mypat.presentation.setting

import android.util.Log
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.a0100019.mypat.data.room.area.Area
import com.a0100019.mypat.data.room.diary.Diary
import com.a0100019.mypat.data.room.diary.DiaryDao
import com.a0100019.mypat.data.room.diary.getDiaryInitialData
import com.a0100019.mypat.data.room.english.English
import com.a0100019.mypat.data.room.english.EnglishDao
import com.a0100019.mypat.data.room.english.getEnglishInitialData
import com.a0100019.mypat.data.room.item.Item
import com.a0100019.mypat.data.room.item.ItemDao
import com.a0100019.mypat.data.room.item.getItemInitialData
import com.a0100019.mypat.data.room.koreanIdiom.KoreanIdiom
import com.a0100019.mypat.data.room.koreanIdiom.KoreanIdiomDao
import com.a0100019.mypat.data.room.koreanIdiom.getKoreanIdiomInitialData
import com.a0100019.mypat.data.room.letter.Letter
import com.a0100019.mypat.data.room.letter.LetterDao
import com.a0100019.mypat.data.room.letter.getLetterInitialData
import com.a0100019.mypat.data.room.area.AreaDao
import com.a0100019.mypat.data.room.area.getAreaInitialData
import com.a0100019.mypat.data.room.pat.Pat
import com.a0100019.mypat.data.room.pat.PatDao
import com.a0100019.mypat.data.room.pat.getPatInitialData
import com.a0100019.mypat.data.room.sudoku.Sudoku
import com.a0100019.mypat.data.room.sudoku.SudokuDao
import com.a0100019.mypat.data.room.sudoku.getSudokuInitialData
import com.a0100019.mypat.data.room.user.User
import com.a0100019.mypat.data.room.user.UserDao
import com.a0100019.mypat.data.room.user.getUserInitialData
import com.a0100019.mypat.data.room.walk.Walk
import com.a0100019.mypat.data.room.walk.WalkDao
import com.a0100019.mypat.data.room.walk.getWalkInitialData
import com.a0100019.mypat.data.room.world.World
import com.a0100019.mypat.data.room.world.WorldDao
import com.a0100019.mypat.data.room.world.getWorldInitialData
import com.a0100019.mypat.domain.AppBgmManager
import com.google.firebase.Firebase
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.firestore.FieldValue
import com.google.firebase.firestore.FirebaseFirestore
import com.google.firebase.firestore.SetOptions
import com.google.firebase.firestore.firestore
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.CoroutineExceptionHandler
import kotlinx.coroutines.launch
import kotlinx.coroutines.tasks.await
import org.orbitmvi.orbit.Container
import org.orbitmvi.orbit.ContainerHost
import org.orbitmvi.orbit.annotation.OrbitExperimental
import org.orbitmvi.orbit.syntax.simple.blockingIntent
import org.orbitmvi.orbit.syntax.simple.intent
import org.orbitmvi.orbit.syntax.simple.postSideEffect
import org.orbitmvi.orbit.syntax.simple.reduce
import org.orbitmvi.orbit.viewmodel.container
import java.time.LocalDateTime
import javax.annotation.concurrent.Immutable
import javax.inject.Inject


@HiltViewModel
class SettingViewModel @Inject constructor(
    private val userDao: UserDao,
    private val patDao: PatDao,
    private val itemDao: ItemDao,
    private val diaryDao: DiaryDao,
    private val englishDao: EnglishDao,
    private val koreanIdiomDao: KoreanIdiomDao,
    private val sudokuDao: SudokuDao,
    private val walkDao: WalkDao,
    private val worldDao: WorldDao,
    private val letterDao: LetterDao,
    private val areaDao: AreaDao
) : ViewModel(), ContainerHost<SettingState, SettingSideEffect> {

    override val container: Container<SettingState, SettingSideEffect> = container(
        initialState = SettingState(),
        buildSettings = {
            this.exceptionHandler = CoroutineExceptionHandler { _ , throwable ->
                intent {
                    postSideEffect(SettingSideEffect.Toast(message = throwable.message.orEmpty()))
                }
            }
        }
    )

    // Î∑∞ Î™®Îç∏ Ï¥àÍ∏∞Ìôî Ïãú Î™®Îì† user Îç∞Ïù¥ÌÑ∞Î•º Î°úÎìú
    init {
        loadData()
    }

    //roomÏóêÏÑú Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏Ïò¥
    private fun loadData() = intent {
        val userDataList = userDao.getAllUserData()
        val itemDataList = itemDao.getAllItemDataWithShadow()
        val patDataList = patDao.getAllPatData()
        val worldDataList = worldDao.getAllWorldData()
        val letterDataList = letterDao.getAllLetterData()
        val walkDataList = walkDao.getAllWalkData()
        val englishDataList = englishDao.getOpenEnglishData()
        val koreanIdiomDataList = koreanIdiomDao.getOpenKoreanIdiomData()
        val diaryDataList = diaryDao.getAllDiaryData()
        val sudokuDataList = sudokuDao.getAllSudokuData()
        val areaDataList = areaDao.getAllAreaData()

        reduce {
            state.copy(
                userDataList = userDataList,
                itemDataList = itemDataList,
                patDataList = patDataList,
                worldDataList = worldDataList,
                letterDataList = letterDataList,
                walkDataList = walkDataList,
                englishDataList = englishDataList,
                koreanIdiomDataList = koreanIdiomDataList,
                diaryDataList = diaryDataList,
                sudokuDataList = sudokuDataList,
                areaDataList = areaDataList
            )
        }
    }

    fun onCloseClick() = intent {
        reduce {
            state.copy(
                settingSituation = "",
                editText = "",
                clickLetterData = Letter(),
                recommending = "-1",
                recommended = "-1"
            )
        }
    }

//    fun onTermsClick() = intent {
//        try {
//            val uri = FirebaseStorage.getInstance()
//                .reference.child("sample.png")
//                .downloadUrl.await()
//
//            reduce {
//                state.copy(imageUrl = uri.toString())
//            }
//        } catch (e: Exception) {
//            // Ïã§Ìå® Ï≤òÎ¶¨ Í∞ÄÎä•
//        }
//    }

    fun onSituationChange(situation: String) = intent {
        reduce {
            state.copy(
                settingSituation = situation
            )
        }
    }

    private fun onSignOutClick() = intent {

        FirebaseAuth.getInstance().signOut()
        // ÌòÑÏû¨ ÏÇ¨Ïö©Ïûê nullÏù¥Î©¥ Î°úÍ∑∏ÏïÑÏõÉ ÏÑ±Í≥µ
        val currentUser = FirebaseAuth.getInstance().currentUser
        if (currentUser == null) {
            // ‚úÖ Î°úÍ∑∏ÏïÑÏõÉ ÏÑ±Í≥µ
            // ÏÇ¨Ïö©Ïûê Îç∞Ïù¥ÌÑ∞ ÏÇ≠Ï†ú
//            userDao.update(id = "auth", value = "0")
            roomDataClear()
            postSideEffect(SettingSideEffect.Toast("Î°úÍ∑∏ÏïÑÏõÉ ÎêòÏóàÏäµÎãàÎã§"))
            postSideEffect(SettingSideEffect.NavigateToLoginScreen)
        } else {
            // ‚ùå Î°úÍ∑∏ÏïÑÏõÉ Ïã§Ìå®
            postSideEffect(SettingSideEffect.Toast("Î°úÍ∑∏ÏïÑÏõÉÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§"))
        }

    }

    fun dataSave() = intent {

        try {
            // ... Ï†ÑÏ≤¥ dataSave() ÎÇ¥Ïö©
        val db = Firebase.firestore
        val userId = state.userDataList.find { it.id == "auth" }!!.value
        val userDataList = state.userDataList
        val itemDataList = state.itemDataList
        val patDataList = state.patDataList
        val worldDataList = state.worldDataList
        val walkDataList = state.walkDataList
        val englishDataList = state.englishDataList
        val diaryDataList = state.diaryDataList
        val koreanIdiomDataList = state.koreanIdiomDataList
        val letterDataList = state.letterDataList
        val sudokuDataList = state.sudokuDataList
        val areaDataList = state.areaDataList

        val batch = db.batch()

        val userData = mapOf(
            "cash" to userDataList.find { it.id == "money"}!!.value2,
            "money" to userDataList.find { it.id == "money"}!!.value,

            "community" to mapOf(
                "ban" to userDataList.find { it.id == "community"}!!.value3,
//                "like" to userDataList.find { it.id == "community"}!!.value,
                "warning" to userDataList.find {it.id == "community"}!!.value2
            ),

            "date" to mapOf(
                "firstDate" to userDataList.find { it.id == "date"}!!.value3,
                "totalDate" to userDataList.find { it.id == "date"}!!.value2,
                "lastDate" to userDataList.find { it.id == "date"}!!.value
            ),

            "game" to mapOf(
                "firstGame" to userDataList.find { it.id == "firstGame"}!!.value,
                "secondGame" to userDataList.find { it.id == "secondGame"}!!.value,
                "thirdGameEasy" to userDataList.find { it.id == "thirdGame"}!!.value,
                "thirdGameNormal" to userDataList.find { it.id == "thirdGame"}!!.value2,
                "thirdGameHard" to userDataList.find { it.id == "thirdGame"}!!.value3,
                ),

            "item" to mapOf(
                "openItem" to itemDataList.count { it.date != "0"}.toString(),
                "openItemSpace" to userDataList.find { it.id == "item"}!!.value2,
                "useItem" to userDataList.find { it.id == "item"}!!.value3
            ),

            "pat" to mapOf(
                "openPat" to patDataList.count { it.date != "0"}.toString(),
                "openPatSpace" to userDataList.find { it.id == "pat"}!!.value2,
                "usePat" to userDataList.find { it.id == "pat"}!!.value3
            ),

            "area" to worldDataList.find { it.id == 1}!!.value,
            "name" to userDataList.find { it.id == "name"}!!.value,
            "lastLogin" to userDataList.find { it.id == "auth"}!!.value3,
            "tag" to userDataList.find { it.id == "auth"}!!.value2,
            "openArea" to areaDataList.count { it.date != "0"}.toString(),

            "online" to "0",

            "walk" to mapOf(
                "saveWalk" to userDataList.find { it.id == "walk"}!!.value,
                "totalWalk" to userDataList.find { it.id == "walk"}!!.value3,
            )

        )

            // üîπ ÏõîÎìú Îç∞Ïù¥ÌÑ∞ ÎßåÎì§Í∏∞
            val worldMap = worldDataList.drop(1)
                .mapIndexed { index, data ->
                    if (data.type == "pat") {
                        val patData = patDataList.find { it.id == data.value.toInt() }
                        index.toString() to mapOf(
                            "id" to data.value,
                            "size" to patData!!.sizeFloat.toString(),
                            "type" to data.type,
                            "x" to patData.x.toString(),
                            "y" to patData.y.toString(),
                            "effect" to patData.effect.toString()
                        )
                    } else {
                        val itemData = itemDataList.find { it.id == data.value.toInt() }
                        index.toString() to mapOf(
                            "id" to data.value,
                            "size" to itemData!!.sizeFloat.toString(),
                            "type" to data.type,
                            "x" to itemData.x.toString(),
                            "y" to itemData.y.toString(),
                            "effect" to "0"
                        )
                    }
                }
                .toMap()

            val userDocRef = Firebase.firestore.collection("users").document(userId)

            // 1) Î¨∏ÏÑú Î≥¥Ïû• (ÏóÜÏúºÎ©¥ ÏÉùÏÑ±)
            batch.set(userDocRef, emptyMap<String, Any>(), SetOptions.merge())

            // 2) Í∏∞Ï°¥ world ÌïÑÎìú Ï†úÍ±∞
            batch.update(userDocRef, mapOf("world" to FieldValue.delete()))

            // 3) userData + ÏÉà world ÌïÑÎìú Î≥ëÌï© Ï†ÄÏû•
            val finalData = userData + mapOf("world" to worldMap)
            batch.set(userDocRef, finalData, SetOptions.merge())

        //Ìé´ Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû•
        val patCollectionRef = db.collection("users")
            .document(userId)
            .collection("dataCollection")

        val combinedPatData = mutableMapOf<String, Any>()
        patDataList
        .filter { it.date != "0" }
        .forEach { patData ->
            val patMap = mapOf(
                "date" to patData.date,
                "love" to patData.love.toString(),
                "size" to patData.sizeFloat.toString(),
                "x" to patData.x.toString(),
                "y" to patData.y.toString(),
                "gameCount" to patData.gameCount.toString(),
                "effect" to patData.effect.toString()
            )
            combinedPatData[patData.id.toString()] = patMap
        }
        batch.set(patCollectionRef.document("pats"), combinedPatData)

        val itemCollectionRef = db.collection("users")
            .document(userId)
            .collection("dataCollection")

        val combinedItemData = mutableMapOf<String, Any>()
        itemDataList
            .filter { it.date != "0" }
            .forEach { itemData ->
                val itemMap = mapOf(
                    "date" to itemData.date,
                    "size" to itemData.sizeFloat.toString(),
                    "x" to itemData.x.toString(),
                    "y" to itemData.y.toString()
                )
                combinedItemData[itemData.id.toString()] = itemMap
            }
        batch.set(itemCollectionRef.document("items"), combinedItemData)

        val areaCollectionRef = db.collection("users")
            .document(userId)
            .collection("dataCollection")

        val combinedMapData = mutableMapOf<String, Any>()
        areaDataList
            .filter { it.date != "0" }
            .forEach { areaData ->
                val areaMap = mapOf(
                    "date" to areaData.date,
                )
                combinedMapData[areaData.id.toString()] = areaMap
            }
        batch.set(areaCollectionRef.document("areas"), combinedMapData)

        val letterCollectionRef = db.collection("users")
        .document(userId)
        .collection("dataCollection")

        val combinedLetterData = mutableMapOf<String, Any>()
        letterDataList.forEach { letterData ->
            val letterMap = mapOf(
                "date" to letterData.date,
                "title" to letterData.title,
                "message" to letterData.message,
                "link" to letterData.link,
                "reward" to letterData.reward,
                "amount" to letterData.amount,
                "state" to letterData.state,
            )
            combinedLetterData[letterData.id.toString()] = letterMap
        }
        // ÌïòÎÇòÏùò Î¨∏ÏÑúÏóê Ï†ÑÏ≤¥ Îç∞Ïù¥ÌÑ∞Î•º Ï†ÄÏû•
        batch.set(letterCollectionRef.document("letters"), combinedLetterData)

        val sudokuCollectionRef = db.collection("users")
            .document(userId)
            .collection("dataCollection")
            .document("sudoku")

        val sudokuData = mapOf(
            "sudokuBoard" to sudokuDataList.find {it.id == "sudokuBoard"}!!.value,
            "sudokuFirstBoard" to sudokuDataList.find {it.id == "sudokuFirstBoard"}!!.value,
            "sudokuMemoBoard" to sudokuDataList.find {it.id == "sudokuMemoBoard"}!!.value,
            "time" to sudokuDataList.find {it.id == "time"}!!.value,
            "level" to sudokuDataList.find {it.id == "level"}!!.value,
            "state" to sudokuDataList.find {it.id == "state"}!!.value
            )
        batch.set(sudokuCollectionRef, sudokuData)

        val dailyCollectionRef = db.collection("users")
        .document(userId)
        .collection("daily")

        for (id in 1..userDataList.find { it.id == "date" }!!.value2.toInt()) {
            val docRef = dailyCollectionRef.document(id.toString())

            // diaryÎäî Ìï≠ÏÉÅ Ï°¥Ïû¨
            val diary = diaryDataList.find { it.id == id }!!
            val walk = walkDataList.find { it.id == id }!!.success

            // state Íµ¨ÏÑ± (Îëò Ï§ë ÌïòÎÇòÎùºÎèÑ nullÏù¥Î©¥ Ï†úÏô∏)
            val englishState = englishDataList.find { it.id == id }?.state
            val idiomState = koreanIdiomDataList.find { it.id == id }?.state

            val data = mutableMapOf<String, Any>(
                "date" to diary.date,
                "diary" to mapOf(
                    "emotion" to diary.emotion,
                    "state" to diary.state,
                    "contents" to diary.contents
                ),
                "walk" to walk
            )

            if (englishState != null && idiomState != null) {
                data["state"] = mapOf(
                    "english" to englishState,
                    "koreanIdiom" to idiomState
                )
            }

            batch.set(docRef, data)
        }

        Log.d("Firestore", "batch.commit() ÏßÅÏ†Ñ")

        // Ï†ÑÏ≤¥ Ïª§Î∞ã Ïã§Ìñâ
        batch.commit()
            .addOnSuccessListener {
                onSignOutClick()
            }
            .addOnFailureListener {
                Log.e("Firestore", "Ï†ÄÏû• Ïã§Ìå®", it)
            }

        } catch (e: Exception) {
            Log.e("Firestore", "ÏòàÏô∏ Î∞úÏÉù", e)
        }
    }

    fun onAccountDeleteClick() = intent {
        if(state.editText == "Í≥ÑÏ†ïÏÇ≠Ï†ú"){
            reduce {
                state.copy(
                    settingSituation = ""
                )
            }

            val auth = FirebaseAuth.getInstance()
            val db = FirebaseFirestore.getInstance()

            val userDocRef =
                db.collection("users").document(state.userDataList.find { it.id == "auth" }!!.value)
            val subCollections =
                listOf("daily", "dataCollection")

            try {
                // 1. ÏÑúÎ∏åÏª¨Î†âÏÖò ÏïàÏùò Î¨∏ÏÑú ÏÇ≠Ï†ú
                for (sub in subCollections) {
                    val subColRef = userDocRef.collection(sub)
                    val documents = subColRef.get().await().documents
                    for (doc in documents) {
                        doc.reference.delete().await()
                    }
                }

                // 2. ÎßàÏßÄÎßâÏúºÎ°ú ÏÇ¨Ïö©Ïûê Î¨∏ÏÑú ÏÇ≠Ï†ú
                userDocRef.delete().await()

                // 2. Authentication Í≥ÑÏ†ï ÏÇ≠Ï†ú
                auth.currentUser?.delete()
                    ?.addOnSuccessListener {
                        viewModelScope.launch {
                            roomDataClear()
                            postSideEffect(SettingSideEffect.Toast("Í≥ÑÏ†ïÏù¥ ÏÇ≠Ï†úÎêòÏóàÏäµÎãàÎã§."))
                            postSideEffect(SettingSideEffect.NavigateToLoginScreen)
                        }
                        Log.d("Auth", "Í≥ÑÏ†ï ÏÇ≠Ï†ú ÏôÑÎ£å")
                    }
                    ?.addOnFailureListener {
                        Log.e("Auth", "Í≥ÑÏ†ï ÏÇ≠Ï†ú Ïã§Ìå®", it)
                        viewModelScope.launch {
                            postSideEffect(SettingSideEffect.Toast("Îã§Ïãú Î°úÍ∑∏Ïù∏ ÌõÑ Ïû¨ÏãúÎèÑ Ìï¥Ï£ºÏÑ∏Ïöî."))
                        }
                    }
                Log.d("Firestore", "ÏÇ¨Ïö©Ïûê Ï†ÑÏ≤¥ ÏÇ≠Ï†ú ÏôÑÎ£å")
            } catch (e: Exception) {
                Log.e("Firestore", "ÏÇ≠Ï†ú Ïã§Ìå®", e)
            }

        } else {
            postSideEffect(SettingSideEffect.Toast("[Í≥ÑÏ†ïÏÇ≠Ï†ú]Î•º ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî."))
        }

    }

    private fun roomDataClear() = intent {
        // Î™®Îì† Ïú†Ï†Ä Îç∞Ïù¥ÌÑ∞ ÏÇ≠Ï†ú
        userDao.deleteAllUsers()
        // Ï¥àÍ∏∞ Îç∞Ïù¥ÌÑ∞ ÏÇΩÏûÖ
        val initialUserData = getUserInitialData()
        userDao.insertAll(initialUserData)

        diaryDao.deleteAllDiary()
        diaryDao.resetDiaryPrimaryKey()
        val initialDiaryData = getDiaryInitialData()
        diaryDao.insertAll(initialDiaryData)

        englishDao.deleteAllEnglish()
        englishDao.resetEnglishPrimaryKey()
        val initialEnglishData = getEnglishInitialData()
        englishDao.insertAll(initialEnglishData)

        itemDao.deleteAllItems()
        itemDao.resetItemPrimaryKey()
        val initialItemData = getItemInitialData()
        itemDao.insertAll(initialItemData)

        koreanIdiomDao.deleteAllKoreanIdioms()
        koreanIdiomDao.resetKoreanIdiomPrimaryKey()
        val initialKoreanIdiomData = getKoreanIdiomInitialData()
        koreanIdiomDao.insertAll(initialKoreanIdiomData)

        letterDao.deleteAllLetters()
        letterDao.resetLetterPrimaryKey()
        val initialLetterData = getLetterInitialData()
        letterDao.insertAll(initialLetterData)

        patDao.deleteAllPats()
        patDao.resetPatPrimaryKey()
        val initialPatData = getPatInitialData()
        patDao.insertAll(initialPatData)

        sudokuDao.deleteAllSudoku()
        val initialSudokuData = getSudokuInitialData()
        sudokuDao.insertAll(initialSudokuData)

        walkDao.deleteAllWalks()
        walkDao.resetWalkPrimaryKey()
        val initialWalkData = getWalkInitialData()
        walkDao.insertAll(initialWalkData)

        worldDao.deleteAllWorlds()
        worldDao.resetWorldPrimaryKey()
        val initialWorldData = getWorldInitialData()
        worldDao.insertAll(initialWorldData)

        areaDao.deleteAllAreas()
        areaDao.resetAreaPrimaryKey()
        val initialAreaData = getAreaInitialData()
        areaDao.insertAll(initialAreaData)

    }

    fun onCouponConfirmClick() = intent {
        val db = Firebase.firestore
        val couponText = state.editText // ÏÇ¨Ïö©ÏûêÍ∞Ä ÏûÖÎ†•Ìïú Ïø†Ìè∞ ÏΩîÎìú
        val userId = state.userDataList.find { it.id == "auth" }!!.value

        db.collection("users").document(userId).collection("code").document("coupon")
            .get()
            .addOnSuccessListener { couponDocument ->
                if (couponDocument != null && couponDocument.contains(couponText)) {
                    // Ïù¥ÎØ∏ ÏÇ¨Ïö©Ìïú Ïø†Ìè∞
                    viewModelScope.launch {
                        postSideEffect(SettingSideEffect.Toast("Ïù¥ÎØ∏ ÏÇ¨Ïö©Ìïú Ïø†Ìè∞ Î≤àÌò∏ÏûÖÎãàÎã§."))
                    }
                } else {
                    // ÏïÑÏßÅ ÏÇ¨Ïö©ÌïòÏßÄ ÏïäÏùÄ Ïø†Ìè∞Ïù¥ÎØÄÎ°ú, Ïú†Ìö®Ìïú Ïø†Ìè∞Ïù∏ÏßÄ ÌôïÏù∏
                    db.collection("code").document("coupon")
                        .get()
                        .addOnSuccessListener { document ->
                            if (document != null && document.contains(couponText)) {
                                val couponData = document.get(couponText) as? Map<*, *>
                                val reward = couponData?.get("reward") as? String
                                val type = couponData?.get("type") as? String
                                val amount = couponData?.get("amount") as? String

                                Log.d("Coupon", "ÎÇ¥Ïö©: $reward, Í∏àÏï°: $amount")

                                val newCouponMap = mapOf(
                                    couponText to mapOf(
                                        "reward" to reward,
                                        "type" to type,
                                        "amount" to amount
                                    )
                                )

                                if(type == "all"){

                                    db.collection("users").document(userId)
                                        .collection("code").document("coupon")
                                        .set(newCouponMap, SetOptions.merge())
                                        .addOnSuccessListener {
                                            viewModelScope.launch {
                                                if (reward == "money") {
                                                    userDao.update(
                                                        id = "money",
                                                        value = (state.userDataList.find { it.id == "money" }!!.value.toInt() + amount!!.toInt()).toString()
                                                    )
                                                } else {
                                                    userDao.update(
                                                        id = "money",
                                                        value2 = (state.userDataList.find { it.id == "money" }!!.value2.toInt() + amount!!.toInt()).toString()
                                                    )
                                                }
                                                postSideEffect(SettingSideEffect.Toast("Ïø†Ìè∞ ÏÇ¨Ïö© : $reward +$amount"))
                                                onCloseClick()
                                                loadData()
                                            }
                                        }
                                        .addOnFailureListener { e ->
                                            Log.e("Coupon", "Ïø†Ìè∞ Ï†ÄÏû• Ïã§Ìå®", e)
                                        }

                                } else if(type == "one"){

                                    db.collection("users").document(userId)
                                        .collection("code").document("coupon")
                                        .set(newCouponMap, SetOptions.merge())
                                        .addOnSuccessListener {
                                            // ÌïÑÎìú ÏÇ≠Ï†ú Î®ºÏ†Ä ÏàòÌñâ
                                            val deleteMap = mapOf<String, Any>(
                                                couponText to FieldValue.delete()
                                            )

                                            db.collection("code").document("coupon")
                                                .update(deleteMap)
                                                .addOnSuccessListener {
                                                    Log.d("Coupon", "Í∏∞Ï°¥ ÌïÑÎìú $couponText ÏÇ≠Ï†ú ÏÑ±Í≥µ")
                                                }
                                                .addOnFailureListener { e ->
                                                    Log.e("Coupon", "Í∏∞Ï°¥ ÌïÑÎìú $couponText ÏÇ≠Ï†ú Ïã§Ìå®", e)
                                                }

                                            viewModelScope.launch {
                                                if (reward == "money") {
                                                    userDao.update(
                                                        id = "money",
                                                        value = (state.userDataList.find { it.id == "money" }!!.value.toInt() + amount!!.toInt()).toString()
                                                    )
                                                } else {
                                                    userDao.update(
                                                        id = "money",
                                                        value2 = (state.userDataList.find { it.id == "money" }!!.value2.toInt() + amount!!.toInt()).toString()
                                                    )
                                                }
                                                postSideEffect(SettingSideEffect.Toast("Ïø†Ìè∞ ÏÇ¨Ïö© : $reward +$amount"))
                                                onCloseClick()
                                                loadData()
                                            }
                                        }
                                        .addOnFailureListener { e ->
                                            Log.e("Coupon", "Ïø†Ìè∞ Ï†ÄÏû• Ïã§Ìå®", e)
                                        }


                                }

                            } else {
                                // Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî Ïø†Ìè∞
                                viewModelScope.launch {
                                    postSideEffect(SettingSideEffect.Toast("Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî Ïø†Ìè∞ Î≤àÌò∏ÏûÖÎãàÎã§."))
                                }
                            }
                        }
                        .addOnFailureListener { e ->
                            Log.e("Coupon", "Ïø†Ìè∞ Ï°∞Ìöå Ïã§Ìå®", e)
                        }
                }
            }
            .addOnFailureListener { e ->
                Log.e("Coupon", "ÏÇ¨Ïö©Ïûê Ïø†Ìè∞ Ï°∞Ìöå Ïã§Ìå®", e)
            }


    }

    fun onSettingTalkConfirmClick() = intent {
        val db = Firebase.firestore
        db.collection("settingTalk")
            .document(state.userDataList.find { it.id == "auth" }!!.value)
            .set(
                mapOf(LocalDateTime.now().toString() to state.editText),
                SetOptions.merge() // Í∏∞Ï°¥ Îç∞Ïù¥ÌÑ∞ Ïú†ÏßÄ + ÌïÑÎìú Ï∂îÍ∞Ä
            )
            .addOnSuccessListener {
                viewModelScope.launch {
                    postSideEffect(SettingSideEffect.Toast("Ï†ÑÏÜ°ÎêòÏóàÏäµÎãàÎã§."))
                    onCloseClick()
                }
            }
    }


    fun clickLetterDataChange(letterId: Int) = intent {
        if(letterId != 0) {

            val clickLetterData = state.letterDataList.find { it.id == letterId }!!


            reduce {
                state.copy(
                    clickLetterData = clickLetterData
                    )
            }

        } else {

            reduce {
                state.copy(
                    clickLetterData = Letter(),
                )
            }
        }

    }

    fun onLetterLinkClick() = intent {
        val url = state.clickLetterData.link
        postSideEffect(SettingSideEffect.OpenUrl(url))
    }

    fun onLetterCloseClick() = intent {
        clickLetterDataChange(0)
        loadData()
    }

    fun onLetterConfirmClick() = intent {

        val letterData = state.clickLetterData

        if(letterData.state == "open"){
            if (letterData.reward == "money") {
                userDao.update(
                    id = "money",
                    value = (state.userDataList.find { it.id == "money" }!!.value.toInt() + letterData.amount.toInt()).toString()
                )
            } else {
                userDao.update(
                    id = "money",
                    value2 = (state.userDataList.find { it.id == "money" }!!.value2.toInt() + letterData.amount.toInt()).toString()
                )
            }
            postSideEffect(SettingSideEffect.Toast("Î≥¥ÏÉÅ ÌöçÎìù : ${letterData.reward} +${letterData.amount}"))

            letterData.state = "read"
            letterDao.update(letterData)
            clickLetterDataChange(0)
            loadData()
        } else {
            clickLetterDataChange(0)
            loadData()
        }

    }

    fun onRecommendationClick() = intent {

        val recommendationDocRef = Firebase.firestore
            .collection("code")
            .document("recommendation")

        val tag = userDao.getValue2ById("auth")

        try {
            val snapshot = recommendationDocRef.get().await()
            val map = snapshot.data as? Map<String, String>

            var recommending = "0"
            var recommended = "0"

            map?.let {
                // tag == key Ï≤¥ÌÅ¨
                if (it.containsKey(tag)) {
                    recommending = it[tag] ?: "0"
                }

                // tag == value Ï≤¥ÌÅ¨
                val matchedEntry = it.entries.find { entry -> entry.value == tag }
                if (matchedEntry != null) {
                    recommended = matchedEntry.key
                }
            }

            Log.d("recommendation", "recommending=$recommending, recommended=$recommended")

            reduce {
                state.copy(
                    recommending = recommending,
                    recommended = recommended,
                    settingSituation = "recommendation"
                )
            }

        } catch (e: Exception) {
            Log.e("recommendation", "Í∞ÄÏ†∏Ïò§Í∏∞ Ïã§Ìå®", e)
            postSideEffect(SettingSideEffect.Toast("Ïù∏ÌÑ∞ÎÑ∑ Ïò§Î•ò"))
        }

    }

    fun onRecommendationSubmitClick() = intent {
        val myTag = userDao.getValue2ById("auth")
        val forTag = state.editText.trim()

        if (myTag == forTag) {
            postSideEffect(SettingSideEffect.Toast("Î≥∏Ïù∏ÏùÑ Ï∂îÏ≤úÌï† Ïàò ÏóÜÏäµÎãàÎã§."))
            return@intent
        }

        val tagDocRef  = Firebase.firestore.collection("tag").document("tag")
        val recoDocRef = Firebase.firestore.collection("code").document("recommendation")
        val letterDocRef = Firebase.firestore.collection("code").document("letter")

        try {
            // 1) forTagÍ∞Ä ÌÉúÍ∑∏ Î¨∏ÏÑúÏùò "ÌÇ§"Ïù∏ÏßÄ ÌôïÏù∏
            val tagSnapshot = tagDocRef.get().await()
            val existsAsKey = (tagSnapshot.data as? Map<String, Any>)?.containsKey(forTag) == true
            if (!existsAsKey) {
                postSideEffect(SettingSideEffect.Toast("Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî ÌÉúÍ∑∏ÏûÖÎãàÎã§."))
                return@intent
            }

            // üîí ÏÑúÎ°ú Ï∂îÏ≤ú Í∏àÏßÄ Ï≤¥ÌÅ¨: recommendationÏóêÏÑú forTag: myTag Í∞Ä Ïù¥ÎØ∏ Ï°¥Ïû¨ÌïòÎ©¥ Í∏àÏßÄ
            val recoSnapshot = recoDocRef.get().await()
            val recoMap = recoSnapshot.data as? Map<String, Any> ?: emptyMap()
            val reciprocal = (recoMap[forTag] as? String) == myTag
            if (reciprocal) {
                postSideEffect(SettingSideEffect.Toast("ÏÑúÎ°ú Ï∂îÏ≤úÌï† Ïàò ÏóÜÏäµÎãàÎã§."))
                return@intent
            }

            // 2) Ï∂îÏ≤ú Îì±Î°ù: recommendation Î¨∏ÏÑúÏóê myTag: forTag
            recoDocRef.update(myTag, forTag).await()
            postSideEffect(SettingSideEffect.Toast("#$forTag ÎãòÏùÑ Ï∂îÏ≤úÌïòÏòÄÏäµÎãàÎã§. +5ÌñáÏÇ¥"))
            reduce { state.copy(recommending = forTag) }

            // 3) letter Î¨∏ÏÑúÏóê Îßµ ÌïÑÎìú Ï∂îÍ∞Ä (ÌÇ§ = yyyyMMdd + forTag)
            val today = java.time.LocalDate.now(java.time.ZoneId.of("Asia/Seoul"))
                .format(java.time.format.DateTimeFormatter.ofPattern("yyyyMMdd"))
            val todayDate = java.time.LocalDate.now(java.time.ZoneId.of("Asia/Seoul"))
                .format(java.time.format.DateTimeFormatter.ofPattern("yyyy-MM-dd"))

            val letterFieldKey = today + forTag // Ïòà: 2025091244
            val letterValue = mapOf(
                "amount" to "10",
                "date" to todayDate,
                "link" to "0",
                "message" to "ÏïàÎÖïÌïòÏÑ∏Ïöî Ïù¥ÏõÉÎãò!\n\n#$myTag ÎãòÏùò Ï∂îÏ≤úÏùÑ Î∞õÏïòÏäµÎãàÎã§. ÌïòÎ£®ÎßàÏùÑÏùÑ ÏúÑÌï¥ Ïï†Ïç®Ï£ºÏÖîÏÑú ÏßÑÏã¨ÏúºÎ°ú Í∞êÏÇ¨Ìï©ÎãàÎã§. Ïù¥ÏõÉÎãòÏùò Ï†ïÏÑ±Í≥º ÎßàÏùåÏù¥ ÌóõÎêòÏßÄ ÏïäÎèÑÎ°ù, ÌïòÎ£®ÎßàÏùÑÏùÄ ÏïûÏúºÎ°úÎèÑ Íæ∏Ï§ÄÌûà ÏÑ±Ïû•ÌïòÎ©∞ Îçî Îî∞ÎúªÌïú Í≥µÍ∞ÑÏù¥ ÎêòÍ≤†ÏäµÎãàÎã§. Ïñ∏Ï†úÎÇò Ìï®ÍªòÌï¥Ï£ºÏÖîÏÑú Í≥†ÎßôÏäµÎãàÎã§.",
                "reward" to "money",
                "state" to "open",
                "title" to "Ï∂îÏ≤úÏù∏ Î≥¥ÏÉÅ"
            )
            letterDocRef.update(letterFieldKey, letterValue).await()

            userDao.update(
                id = "money",
                value = (state.userDataList.find { it.id == "money" }!!.value.toInt() + 5).toString()
            )

        } catch (e: Exception) {
            Log.e("recommendation", "Ï≤òÎ¶¨ Ïã§Ìå®", e)
            postSideEffect(SettingSideEffect.Toast("Ï≤òÎ¶¨ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§."))
        }
    }

    //ÏûÖÎ†• Í∞ÄÎä•ÌïòÍ≤å ÌïòÎäî ÏΩîÎìú
    @OptIn(OrbitExperimental::class)
    fun onEditTextChange(editText: String) = blockingIntent {
        reduce {
            state.copy(editText = editText)
        }
    }

}


@Immutable
data class SettingState(
    val userDataList: List<User> = emptyList(),
    val isLoggingIn:Boolean = false,
    val patDataList: List<Pat> = emptyList(),
    val itemDataList: List<Item> = emptyList(),
    val worldDataList: List<World> = emptyList(),
    val walkDataList: List<Walk> = emptyList(),
    val englishDataList: List<English> = emptyList(),
    val koreanIdiomDataList: List<KoreanIdiom> = emptyList(),
    val diaryDataList: List<Diary> = emptyList(),
    val settingSituation: String = "",
    val imageUrl: String = "",
    val editText: String = "",
    val clickLetterData: Letter = Letter(),
    val letterDataList: List<Letter> = emptyList(),
    val sudokuDataList: List<Sudoku> = emptyList(),
    val areaDataList: List<Area> = emptyList(),
    val recommending: String = "-1",
    val recommended: String = "-1"
    )


sealed interface SettingSideEffect {
    class Toast(val message: String) : SettingSideEffect
    data object NavigateToLoginScreen : SettingSideEffect
    data class OpenUrl(val url: String) : SettingSideEffect

}
